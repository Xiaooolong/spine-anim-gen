# 重写 SpinePixiPreview 组件计划

用户反馈预览组件仍然存在严重的显示位置偏移和不可见问题。鉴于“修补式”修复效果不佳，我计划**完全重写**该组件的核心逻辑，不再依赖 PixiJS 的动态边界检测，而是采用**正向运动学 (FK) 预计算**的方式来绝对掌控渲染位置。

## 1. 核心问题分析
*   **数据源坐标偏移**：`retarget.ts` 生成的 `hip` 位移使用的是视频原始像素坐标（如 1920x1080 范围），导致骨骼整体远离原点。
*   **动态边界不稳定**：依赖 PixiJS `getLocalBounds()` 在每帧动态调整视口，容易因渲染延迟或计算误差导致画面抖动、飞出或缩放异常。
*   **渲染逻辑不透明**：之前的组件混合了逻辑与渲染，难以调试具体的坐标数值。

## 2. 实施方案

### 第一步：实现正向运动学 (FK) 预计算器
编写一个纯 TypeScript 工具函数，在动画加载后立即运行：
1.  **解析骨骼层级**：建立骨骼父子树。
2.  **采样所有帧**：以一定频率（如每秒 30 帧）遍历整个动画时长。
3.  **计算世界坐标**：
    *   对于每一帧，计算 `hip` 的绝对位置。
    *   递归计算所有子骨骼的**世界坐标**（父骨骼位置 + 旋转后的长度向量）。
4.  **生成全局包围盒 (Global AABB)**：
    *   遍历所有采样点的所有骨骼坐标。
    *   计算出覆盖整个动画过程的 `minX, maxX, minY, maxY`。
    *   这将作为视口适配的**唯一真理**。

### 第二步：重写渲染组件 (SpinePixiPreview)
摒弃旧代码，重新构建：
1.  **静态视口锁定**：
    *   根据预计算的 Global AABB，计算出动画的中心点 `(centerX, centerY)` 和尺寸。
    *   设定一个**固定**的缩放比例和位移，将动画中心点对齐到 Canvas 中心。
    *   **不再在每帧 update 中调整视口**，确保画面绝对稳定。
2.  **简化渲染层**：
    *   使用扁平化的渲染方式（或简单的层级），直接利用 FK 计算出的每帧数据进行绘制，或者沿用 Pixi 容器层级但锁定 Root 容器的位置。
    *   绘制风格优化：使用胶囊体（Capsule）表示肢体，区分左右颜色，增加关节圆点。
3.  **调试辅助**：
    *   在 Canvas 背景绘制一个十字准星表示屏幕中心。
    *   画出计算出的 Global AABB 边框（绿色），证明视口计算正确。

## 3. 预期效果
*   无论原视频坐标是在 (0,0) 还是 (5000, 5000)，预览画面都会自动“对焦”到动画主体。
*   动画播放平滑，无抖动。
*   角色大小适中，自动填满 Canvas 的 80% 区域。

我将从头编写这个组件，确保逻辑清晰可控。